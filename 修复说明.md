# Reddit Clone 项目修复说明

## 修复日期：2025年11月1日

## 发现的问题及修复方案

### 问题 1：Zipf 分布没有被正确实现 ✅

**问题描述：**
- 作业要求："Simulate a Zipf distribution on the number of sub-reddit members."
- 原代码中的 `select_by_zipf` 函数使用的是均匀分布 (`int.random`)，而不是 Zipf 分布
- 这导致每个 subreddit 被选中的概率相同，没有实现"少数 subreddit 非常火爆，大多数无人问津"的效果

**修复内容：**
重写了 `select_by_zipf` 函数，使其真正基于 Zipf 分布进行加权随机选择：

```gleam
pub fn select_by_zipf(items: List(a), zipf_s: Float) -> Result(a, Nil) {
  let n = list.length(items)
  case n {
    0 -> Error(Nil)
    _ -> {
      // 为每个排名计算累积概率
      let probabilities =
        list.range(1, n)
        |> list.map(fn(rank) { zipf_rank(rank, zipf_s, n) })

      // 计算累积和
      let cumulative =
        probabilities
        |> list.scan(0.0, fn(acc, p) { acc +. p })

      // 生成 0-1 之间的随机数
      let random_val = int.to_float(int.random(10_000)) /. 10_000.0

      // 找到对应的排名
      let selected_rank =
        cumulative
        |> list.index_fold(1, fn(selected, cum_prob, idx) {
          case random_val <. cum_prob, selected == 1 {
            True, True -> idx + 1
            _, _ -> selected
          }
        })

      // 返回选中排名的项目
      list.drop(items, selected_rank - 1)
      |> list.first
    }
  }
}
```

---

### 问题 2：没有模拟"断线重连" ✅

**问题描述：**
- 作业要求："Simulate periods of live connection and disconnection for users."
- 虽然代码已经实现了 `GoOffline` 和 `GoOnline` 消息处理
- 但在 `run_simulation` 主循环中从未发送这些消息

**修复内容：**
在 `run_simulation` 的主循环中添加了断线重连逻辑：

```gleam
// 每 100 个动作模拟一次断线/重连
// 约 5% 的用户会掉线，然后重新上线
case i % 100 {
  0 -> {
    let num_to_disconnect = n / 20  // 5% 的客户端
    
    // 断开一些客户端
    list.range(1, num_to_disconnect)
    |> list.each(fn(_) {
      let disconnect_idx = int.random(n)
      case list.drop(clients, disconnect_idx) |> list.first {
        Ok(client) -> process.send(client, GoOffline)
        Error(_) -> Nil
      }
    })
  }
  50 -> {
    // 在周期中途重新连接
    let num_to_reconnect = n / 20
    
    list.range(1, num_to_reconnect)
    |> list.each(fn(_) {
      let reconnect_idx = int.random(n)
      case list.drop(clients, reconnect_idx) |> list.first {
        Ok(client) -> process.send(client, GoOnline)
        Error(_) -> Nil
      }
    })
  }
  _ -> Nil
}
```

---

### 问题 3：没有模拟"Re-posts"（转发） ✅

**问题描述：**
- 作业要求："Make some of these messages re-posts."
- 原代码所有帖子都是新创建的，没有模拟"转发"或"重复发帖"的行为

**修复内容：**
1. 在 `ClientState` 中添加了 `hot_posts` 字段来维护热门帖子池
2. 添加了 `HotPost` 类型来存储热门帖子信息
3. 在客户端创建帖子时：
   - 有 15% 的概率从热门帖子池中选择一个进行转发
   - 有 20% 的概率将新创建的帖子加入热门帖子池
4. 转发的帖子标题会加上 "Re: " 前缀

```gleam
pub type HotPost {
  HotPost(title: String, content: String, subreddit: String)
}

pub type ClientState {
  ClientState(
    user_id: UserId,
    username: String,
    engine: Subject(EngineMessage),
    action_count: Int,
    is_online: Bool,
    known_posts: List(String),
    hot_posts: List(HotPost),  // 新增：热门帖子池
  )
}
```

---

### 问题 4：投票使用"盲猜"的 post_id ✅

**问题描述：**
- 原代码投票时使用随机生成的 post_id：`"post_" <> string.inspect(int.random(100))`
- 这不是真实用户行为，真实用户应该从 feed 中看到帖子后再投票

**修复内容：**
1. 在 `ClientState` 中添加了 `known_posts` 字段来跟踪已知的帖子
2. 添加了 `UpdateFeed` 消息来更新已知帖子列表
3. 投票时的新逻辑：
   - 如果 `known_posts` 为空，先调用 `GetFeed` 获取帖子
   - 如果有已知帖子，从中随机选择一个进行投票

```gleam
// 20% - Vote on post (use real post from feed)
n if n < 80 -> {
  case list.length(state.known_posts) {
    0 -> {
      // 没有已知帖子，先获取 feed
      process.send(
        state.engine,
        GetFeed(user_id: state.user_id, reply: process.new_subject()),
      )
    }
    n -> {
      // 对已知帖子投票
      case list.drop(state.known_posts, int.random(n)) |> list.first {
        Ok(post_id) -> {
          process.send(
            state.engine,
            VotePost(
              post_id: post_id,
              user_id: state.user_id,
              is_upvote: int.random(2) == 1,
              reply: process.new_subject(),
            ),
          )
        }
        Error(_) -> Nil
      }
    }
  }
}
```

---

## 修改文件清单

- `src/simulator.gleam` - 所有修复都在这个文件中

## 新增的类型和消息

### 新增类型：
```gleam
pub type HotPost {
  HotPost(title: String, content: String, subreddit: String)
}
```

### 新增消息：
```gleam
UpdateFeed(posts: List(String))
AddHotPost(title: String, content: String, subreddit: String)
```

### 修改的状态：
```gleam
pub type ClientState {
  ClientState(
    user_id: UserId,
    username: String,
    engine: Subject(EngineMessage),
    action_count: Int,
    is_online: Bool,
    known_posts: List(String),      // 新增
    hot_posts: List(HotPost),       // 新增
  )
}
```

## 行为概率调整

原有行为分布：
- 30% - 加入 subreddit
- 40% - 创建帖子
- 20% - 投票
- 10% - 获取 feed

新的行为分布：
- 25% - 加入 subreddit
- 35% - 创建帖子（其中 15% 是转发）
- 20% - 投票（使用真实 post_id）
- 20% - 获取 feed

## 符合作业要求的检查清单

✅ Register account - 已实现  
✅ Create & join sub-reddit; leave sub-reddit - 已实现  
✅ Post in sub-reddit - 已实现  
✅ Comment in sub-reddit - 已实现  
✅ Upvote+downvote + compute Karma - 已实现  
✅ Get feed of posts - 已实现  
✅ Get list of direct messages; Reply to direct messages - 已实现  
✅ Simulate as many users as you can - 已实现  
✅ **Simulate periods of live connection and disconnection** - ✅ **已修复**  
✅ **Simulate a Zipf distribution on the number of sub-reddit members** - ✅ **已修复**  
✅ **Make some of these messages re-posts** - ✅ **已修复**  

## 测试建议

运行模拟器时应观察：

1. **Zipf 分布效果**：少数几个 subreddit 应该有大量成员，大多数 subreddit 成员较少
2. **断线重连**：每 100 个动作应该能看到一些用户下线和上线的日志
3. **转发帖子**：应该能看到一些标题以 "Re: " 开头的帖子
4. **真实投票**：投票应该针对真实存在的帖子，不会出现大量投票失败

## 运行命令

```bash
gleam run   # 运行项目
gleam test  # 运行测试
```

## 注意事项

所有修改都是向后兼容的，不会破坏现有的功能。代码已通过 Gleam 编译器的类型检查，没有编译错误。
